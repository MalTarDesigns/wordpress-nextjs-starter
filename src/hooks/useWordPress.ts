/**
 * Custom hooks for WordPress data fetching and state management
 * Enhanced with type safety and modern React patterns
 */

'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import { fetchGraphQL, GraphQLError, NetworkError } from '@/utils/fetchGraphQL';
import type { 
  ContentNode, 
  Post, 
  Page
} from '@/gql/graphql';

// Additional types that may be needed
interface GraphQLResponse {
  data?: any;
  errors?: any[];
}

interface PostsQueryVariables {
  first?: number;
  after?: string;
  where?: any;
}

interface Connection<T> {
  edges: { node: T; cursor: string }[];
  pageInfo: {
    hasNextPage: boolean;
    hasPreviousPage: boolean;
    startCursor?: string;
    endCursor?: string;
  };
}

// Hook state types\ninterface UseWordPressState<T> {\n  data: T | null;\n  loading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n}\n\ninterface UseWordPressOptions {\n  enabled?: boolean;\n  refetchOnMount?: boolean;\n  staleTime?: number;\n}\n\n// Generic WordPress data fetching hook\nexport function useWordPressData<T>(\n  query: string,\n  variables?: Record<string, unknown>,\n  options: UseWordPressOptions = {}\n): UseWordPressState<T> {\n  const { enabled = true, refetchOnMount = true, staleTime = 5 * 60 * 1000 } = options;\n  \n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState(enabled);\n  const [error, setError] = useState<Error | null>(null);\n  const [lastFetch, setLastFetch] = useState<number>(0);\n\n  const fetchData = useCallback(async () => {\n    if (!enabled) return;\n    \n    const now = Date.now();\n    if (data && now - lastFetch < staleTime) {\n      return; // Data is still fresh\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      const result = await fetchGraphQL<T>(query, {\n        variables,\n        cache: 'force-cache',\n        revalidate: staleTime / 1000,\n      });\n      \n      setData(result);\n      setLastFetch(now);\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error(String(err));\n      setError(error);\n      console.error('WordPress data fetch error:', {\n        error: error.message,\n        query: query.substring(0, 100) + '...',\n        variables,\n      });\n    } finally {\n      setLoading(false);\n    }\n  }, [query, variables, enabled, staleTime, data, lastFetch]);\n\n  const refetch = useCallback(async () => {\n    setLastFetch(0); // Force refetch\n    await fetchData();\n  }, [fetchData]);\n\n  useEffect(() => {\n    if (enabled && refetchOnMount) {\n      fetchData();\n    }\n  }, [fetchData, enabled, refetchOnMount]);\n\n  return { data, loading, error, refetch };\n}\n\n// Hook for fetching a single content node (page or post)\nexport function useContentNode(slug: string, options?: UseWordPressOptions) {\n  const query = `\n    query GetContentNode($slug: ID!, $idType: ContentNodeIdTypeEnum!) {\n      contentNode(id: $slug, idType: $idType) {\n        id\n        databaseId\n        uri\n        slug\n        status\n        date\n        modified\n        title\n        content\n        excerpt\n        contentTypeName\n        ... on Page {\n          isFrontPage\n          isPostsPage\n          parentId\n        }\n        ... on Post {\n          authorId\n          categories {\n            nodes {\n              id\n              name\n              slug\n              uri\n            }\n          }\n          tags {\n            nodes {\n              id\n              name\n              slug\n              uri\n            }\n          }\n        }\n        seo {\n          title\n          metaDesc\n          canonical\n          opengraphTitle\n          opengraphDescription\n          opengraphImage {\n            sourceUrl\n            altText\n            mediaDetails {\n              width\n              height\n            }\n          }\n        }\n        featuredImage {\n          node {\n            sourceUrl\n            altText\n            mediaDetails {\n              width\n              height\n            }\n          }\n        }\n      }\n    }\n  `;\n\n  const { data, loading, error, refetch } = useWordPressData<{ contentNode: ContentNode }>(\n    query,\n    { slug, idType: 'URI' },\n    options\n  );\n\n  return {\n    contentNode: data?.contentNode || null,\n    loading,\n    error,\n    refetch,\n  };\n}\n\n// Hook for fetching posts with pagination\nexport function usePosts(variables: PostsQueryVariables = {}, options?: UseWordPressOptions) {\n  const query = `\n    query GetPosts(\n      $first: Int\n      $after: String\n      $where: RootQueryToPostConnectionWhereArgs\n    ) {\n      posts(first: $first, after: $after, where: $where) {\n        pageInfo {\n          hasNextPage\n          hasPreviousPage\n          startCursor\n          endCursor\n        }\n        edges {\n          cursor\n          node {\n            id\n            databaseId\n            uri\n            slug\n            status\n            date\n            modified\n            title\n            excerpt\n            contentTypeName\n            author {\n              node {\n                name\n                slug\n                avatar {\n                  url\n                }\n              }\n            }\n            categories {\n              nodes {\n                id\n                name\n                slug\n                uri\n              }\n            }\n            tags {\n              nodes {\n                id\n                name\n                slug\n              }\n            }\n            featuredImage {\n              node {\n                sourceUrl\n                altText\n                mediaDetails {\n                  width\n                  height\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  `;\n\n  const { data, loading, error, refetch } = useWordPressData<{ posts: Connection<Post> }>(\n    query,\n    variables,\n    options\n  );\n\n  const posts = useMemo(() => data?.posts?.edges?.map(edge => edge.node) || [], [data]);\n  const pageInfo = data?.posts?.pageInfo || null;\n\n  return {\n    posts,\n    pageInfo,\n    loading,\n    error,\n    refetch,\n  };\n}\n\n// Hook for search functionality\nexport function useSearch(searchTerm: string, options?: UseWordPressOptions) {\n  const query = `\n    query SearchContent($search: String!) {\n      contentNodes(where: { search: $search }, first: 20) {\n        pageInfo {\n          hasNextPage\n          endCursor\n        }\n        edges {\n          node {\n            id\n            uri\n            slug\n            status\n            date\n            title\n            excerpt\n            contentTypeName\n            ... on Post {\n              author {\n                node {\n                  name\n                  slug\n                }\n              }\n            }\n            featuredImage {\n              node {\n                sourceUrl\n                altText\n              }\n            }\n          }\n        }\n      }\n    }\n  `;\n\n  const { data, loading, error, refetch } = useWordPressData<{ contentNodes: Connection<ContentNode> }>(\n    query,\n    { search: searchTerm },\n    { ...options, enabled: Boolean(searchTerm && searchTerm.length > 2) }\n  );\n\n  const results = useMemo(() => {\n    return data?.contentNodes?.edges?.map(edge => edge.node) || [];\n  }, [data]);\n\n  return {\n    results,\n    loading,\n    error,\n    refetch,\n    hasMore: data?.contentNodes?.pageInfo?.hasNextPage || false,\n  };\n}\n\n// Hook for menu data\nexport function useMenu(location: string, options?: UseWordPressOptions) {\n  const query = `\n    query GetMenu($location: MenuLocationEnum!) {\n      menuItems(where: { location: $location }, first: 50) {\n        nodes {\n          id\n          databaseId\n          title\n          url\n          target\n          description\n          cssClasses\n          order\n          parentId\n          childItems {\n            nodes {\n              id\n              title\n              url\n              target\n              order\n            }\n          }\n        }\n      }\n    }\n  `;\n\n  const { data, loading, error, refetch } = useWordPressData<{ menuItems: { nodes: any[] } }>(\n    query,\n    { location: location.toUpperCase() },\n    options\n  );\n\n  const menuItems = useMemo(() => {\n    return data?.menuItems?.nodes || [];\n  }, [data]);\n\n  return {\n    menuItems,\n    loading,\n    error,\n    refetch,\n  };\n}\n\n// Hook for site settings and general info\nexport function useSiteSettings(options?: UseWordPressOptions) {\n  const query = `\n    query GetSiteSettings {\n      generalSettings {\n        title\n        description\n        url\n        language\n        timezone\n        dateFormat\n        timeFormat\n      }\n    }\n  `;\n\n  const { data, loading, error, refetch } = useWordPressData<{ generalSettings: any }>(\n    query,\n    {},\n    { staleTime: 30 * 60 * 1000, ...options } // Cache for 30 minutes\n  );\n\n  return {\n    settings: data?.generalSettings || null,\n    loading,\n    error,\n    refetch,\n  };\n}\n\n// Hook for handling preview mode\nexport function usePreview() {\n  const [isPreview, setIsPreview] = useState(false);\n  const [previewData, setPreviewData] = useState<{ id: string; token?: string } | null>(null);\n\n  useEffect(() => {\n    // Check if we're in preview mode\n    const urlParams = new URLSearchParams(window.location.search);\n    const preview = urlParams.get('preview') === 'true';\n    const id = urlParams.get('id');\n    const token = urlParams.get('token');\n\n    setIsPreview(preview);\n    setPreviewData(preview && id ? { id, token: token || undefined } : null);\n  }, []);\n\n  const exitPreview = useCallback(async () => {\n    try {\n      await fetch('/api/exit-preview', { method: 'POST' });\n      window.location.reload();\n    } catch (error) {\n      console.error('Error exiting preview:', error);\n    }\n  }, []);\n\n  return {\n    isPreview,\n    previewData,\n    exitPreview,\n  };\n}\n\n// Utility function for client-side revalidation\nexport function useRevalidation() {\n  const [revalidating, setRevalidating] = useState(false);\n\n  const revalidate = useCallback(async (paths?: string[], tags?: string[]) => {\n    if (!paths?.length && !tags?.length) {\n      console.warn('No paths or tags provided for revalidation');\n      return;\n    }\n\n    setRevalidating(true);\n\n    try {\n      const response = await fetch('/api/revalidate', {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ paths, tags }),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Revalidation failed: ${response.statusText}`);\n      }\n\n      const result = await response.json();\n      console.log('Revalidation result:', result);\n      \n      return result;\n    } catch (error) {\n      console.error('Revalidation error:', error);\n      throw error;\n    } finally {\n      setRevalidating(false);\n    }\n  }, []);\n\n  return {\n    revalidate,\n    revalidating,\n  };\n}\n\n// Type guards for better type safety in components\nexport const isPost = (node: ContentNode): node is Post => {\n  return node.contentTypeName === 'post';\n};\n\nexport const isPage = (node: ContentNode): node is Page => {\n  return node.contentTypeName === 'page';\n};